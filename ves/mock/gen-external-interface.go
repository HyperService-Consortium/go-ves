// Code generated by MockGen. DO NOT EDIT.
// Source: ../control/gen-external-interface.go

// Package mock is a generated GoMock package.
package mock

import (
	json "encoding/json"
	opintent "github.com/HyperService-Consortium/go-uip/op-intent"
	uiptypes "github.com/HyperService-Consortium/go-uip/uiptypes"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// OpIntentInitializer is a mock of OpIntentInitializerI interface
type OpIntentInitializer struct {
	ctrl     *gomock.Controller
	recorder *OpIntentInitializerMockRecorder
}

// OpIntentInitializerMockRecorder is the mock recorder for OpIntentInitializer
type OpIntentInitializerMockRecorder struct {
	mock *OpIntentInitializer
}

// NewOpIntentInitializer creates a new mock instance
func NewOpIntentInitializer(ctrl *gomock.Controller) *OpIntentInitializer {
	mock := &OpIntentInitializer{ctrl: ctrl}
	mock.recorder = &OpIntentInitializerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *OpIntentInitializer) EXPECT() *OpIntentInitializerMockRecorder {
	return m.recorder
}

// InitContractInvocationOpIntent mocks base method
func (m *OpIntentInitializer) InitContractInvocationOpIntent(arg0 string, arg1 json.RawMessage) ([]*uiptypes.TransactionIntent, []*uiptypes.MerkleProofProposal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitContractInvocationOpIntent", arg0, arg1)
	ret0, _ := ret[0].([]*uiptypes.TransactionIntent)
	ret1, _ := ret[1].([]*uiptypes.MerkleProofProposal)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// InitContractInvocationOpIntent indicates an expected call of InitContractInvocationOpIntent
func (mr *OpIntentInitializerMockRecorder) InitContractInvocationOpIntent(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitContractInvocationOpIntent", reflect.TypeOf((*OpIntentInitializer)(nil).InitContractInvocationOpIntent), arg0, arg1)
}

// InitOpIntent mocks base method
func (m *OpIntentInitializer) InitOpIntent(arg0 uiptypes.OpIntents) ([]*uiptypes.TransactionIntent, []*uiptypes.MerkleProofProposal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitOpIntent", arg0)
	ret0, _ := ret[0].([]*uiptypes.TransactionIntent)
	ret1, _ := ret[1].([]*uiptypes.MerkleProofProposal)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// InitOpIntent indicates an expected call of InitOpIntent
func (mr *OpIntentInitializerMockRecorder) InitOpIntent(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitOpIntent", reflect.TypeOf((*OpIntentInitializer)(nil).InitOpIntent), arg0)
}

// InitPaymentOpIntent mocks base method
func (m *OpIntentInitializer) InitPaymentOpIntent(arg0 string, arg1 json.RawMessage) ([]*uiptypes.TransactionIntent, []*uiptypes.MerkleProofProposal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitPaymentOpIntent", arg0, arg1)
	ret0, _ := ret[0].([]*uiptypes.TransactionIntent)
	ret1, _ := ret[1].([]*uiptypes.MerkleProofProposal)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// InitPaymentOpIntent indicates an expected call of InitPaymentOpIntent
func (mr *OpIntentInitializerMockRecorder) InitPaymentOpIntent(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitPaymentOpIntent", reflect.TypeOf((*OpIntentInitializer)(nil).InitPaymentOpIntent), arg0, arg1)
}

// TopologicalSort mocks base method
func (m *OpIntentInitializer) TopologicalSort(arg0 [][]*uiptypes.TransactionIntent, arg1 []opintent.Dependency) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopologicalSort", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// TopologicalSort indicates an expected call of TopologicalSort
func (mr *OpIntentInitializerMockRecorder) TopologicalSort(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopologicalSort", reflect.TypeOf((*OpIntentInitializer)(nil).TopologicalSort), arg0, arg1)
}

// BlockChainInterface is a mock of BlockChainInterfaceI interface
type BlockChainInterface struct {
	ctrl     *gomock.Controller
	recorder *BlockChainInterfaceMockRecorder
}

// BlockChainInterfaceMockRecorder is the mock recorder for BlockChainInterface
type BlockChainInterfaceMockRecorder struct {
	mock *BlockChainInterface
}

// NewBlockChainInterface creates a new mock instance
func NewBlockChainInterface(ctrl *gomock.Controller) *BlockChainInterface {
	mock := &BlockChainInterface{ctrl: ctrl}
	mock.recorder = &BlockChainInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *BlockChainInterface) EXPECT() *BlockChainInterfaceMockRecorder {
	return m.recorder
}

// CheckAddress mocks base method
func (m *BlockChainInterface) CheckAddress(arg0 []uint8) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAddress", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckAddress indicates an expected call of CheckAddress
func (mr *BlockChainInterfaceMockRecorder) CheckAddress(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAddress", reflect.TypeOf((*BlockChainInterface)(nil).CheckAddress), arg0)
}

// Deserialize mocks base method
func (m *BlockChainInterface) Deserialize(arg0 []uint8) (uiptypes.RawTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deserialize", arg0)
	ret0, _ := ret[0].(uiptypes.RawTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Deserialize indicates an expected call of Deserialize
func (mr *BlockChainInterfaceMockRecorder) Deserialize(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deserialize", reflect.TypeOf((*BlockChainInterface)(nil).Deserialize), arg0)
}

// GetStorageAt mocks base method
func (m *BlockChainInterface) GetStorageAt(arg0 uint64, arg1 uiptypes.TypeID, arg2, arg3, arg4 []uint8) (uiptypes.Variable, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageAt", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(uiptypes.Variable)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStorageAt indicates an expected call of GetStorageAt
func (mr *BlockChainInterfaceMockRecorder) GetStorageAt(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageAt", reflect.TypeOf((*BlockChainInterface)(nil).GetStorageAt), arg0, arg1, arg2, arg3, arg4)
}

// GetTransactionProof mocks base method
func (m *BlockChainInterface) GetTransactionProof(arg0 uint64, arg1, arg2 []uint8) (uiptypes.MerkleProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionProof", arg0, arg1, arg2)
	ret0, _ := ret[0].(uiptypes.MerkleProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionProof indicates an expected call of GetTransactionProof
func (mr *BlockChainInterfaceMockRecorder) GetTransactionProof(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionProof", reflect.TypeOf((*BlockChainInterface)(nil).GetTransactionProof), arg0, arg1, arg2)
}

// MustWithSigner mocks base method
func (m *BlockChainInterface) MustWithSigner() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MustWithSigner")
	ret0, _ := ret[0].(bool)
	return ret0
}

// MustWithSigner indicates an expected call of MustWithSigner
func (mr *BlockChainInterfaceMockRecorder) MustWithSigner() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustWithSigner", reflect.TypeOf((*BlockChainInterface)(nil).MustWithSigner))
}

// RouteRaw mocks base method
func (m *BlockChainInterface) RouteRaw(arg0 uint64, arg1 uiptypes.RawTransaction) ([]uint8, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RouteRaw", arg0, arg1)
	ret0, _ := ret[0].([]uint8)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RouteRaw indicates an expected call of RouteRaw
func (mr *BlockChainInterfaceMockRecorder) RouteRaw(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RouteRaw", reflect.TypeOf((*BlockChainInterface)(nil).RouteRaw), arg0, arg1)
}

// RouteWithSigner mocks base method
func (m *BlockChainInterface) RouteWithSigner(arg0 uiptypes.Signer) (uiptypes.Router, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RouteWithSigner", arg0)
	ret0, _ := ret[0].(uiptypes.Router)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RouteWithSigner indicates an expected call of RouteWithSigner
func (mr *BlockChainInterfaceMockRecorder) RouteWithSigner(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RouteWithSigner", reflect.TypeOf((*BlockChainInterface)(nil).RouteWithSigner), arg0)
}

// Translate mocks base method
func (m *BlockChainInterface) Translate(arg0 *uiptypes.TransactionIntent, arg1 uiptypes.Storage) (uiptypes.RawTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Translate", arg0, arg1)
	ret0, _ := ret[0].(uiptypes.RawTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Translate indicates an expected call of Translate
func (mr *BlockChainInterfaceMockRecorder) Translate(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Translate", reflect.TypeOf((*BlockChainInterface)(nil).Translate), arg0, arg1)
}

// WaitForTransact mocks base method
func (m *BlockChainInterface) WaitForTransact(arg0 uint64, arg1 []uint8, arg2 ...interface{}) ([]uint8, []uint8, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WaitForTransact", varargs...)
	ret0, _ := ret[0].([]uint8)
	ret1, _ := ret[1].([]uint8)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// WaitForTransact indicates an expected call of WaitForTransact
func (mr *BlockChainInterfaceMockRecorder) WaitForTransact(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForTransact", reflect.TypeOf((*BlockChainInterface)(nil).WaitForTransact), varargs...)
}
